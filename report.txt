Source code can be found here: https://github.com/mtask/vulnerableapp . Application is created with python2.7 and Flask microframework. "How to" -instructions for the app can be found in repository's readme page. Next I go through security flaws and logic mistakes of the application. The app itself is very simple where logged in users can send public comments or private notes. 

1. SQL-injection
Applications login form has SQL-injection vulnerability which allows attacker to login without knowing credentials.

- Steps to identify:
Simple way to notice injection flaw is to give input like "'anything"(without "") to username input and anything to password and then submit. That will cause "sqlite3.OperationalError" exception.
To actually exploit this flaw insert string like "'OR '1'='1"(without "") in username and password inputs. Then press login. You will be now logged in as first user in database. 

- How to fix:
Passwords are stored as plaintext in database so hashing+salt should of course be used. Of course plaintext stored passwords are bad in general but exactly with this issue also if hashing is used it usually prevents the attack described above. When attacker gives malicious input for password like "'OR '1'='1" hash+salt will turn it in somehting like "a4fe1eb5a3cfbdf28a32abb24095eefa" and of course then it doesn't have same kind of affect in sql select statement. Also prepared statements should be used in every sql statement of the application so sql injection flaws could be prevented in general. 


2. Reflected Cross site scripting:
Application has reflected xss vulnerability in its search function. If search doesn't come up with any results users input is reflected back. This allows attacker to craft malicious url for the search.

- Steps to identify:
When search function of app is being used it can be noticed that it takes one paramater "srchterm" so testing with some malicious input will help to learn that application is vulnerable to xss attack. Full example:
http://<theapp>/search?srchterm=<script>alert(1)</script>

Note: Some browsers like latest version of Google Chrome seems to block this attack. Chrome actually tels in console of developers tool that it has blocked javascript from running to prevent xss attack. But this has tested to work with latest Firefox and Internet Explorer 11.

- How to fix:
Every input should be consired as unsafe and be escaped. With Jinja templates that flask uses this flaw would be actually fixed by default so just removing "| safe" from displayed variables in templates fixes this.

3. Stored Cross site scripting
Application also has stored xss vulneralibity. When comments are send and displayed to user the data isn't escaped. 

- Steps to identify:

Post comment to site with string like "<script>alert(1);</script>". Now javascript is being executed when index or users home page is loaded.

- How to fix:

Same fix as in reflected xss. In short, escape all input given by users.

4.Missing function level access control
When user accesses to his private notes it's being checked that user is authenticated but not that current user is the user whos data is being requested.

- Steps to identify:
Launch app and when logged in select "My notes" from navbar. Now applications path is "/home/id/<users_id>". Now by changing id number in url user can access other users private notes.

- How to fix:
Now app only checks that user accessing '/home/id/<id>' is authenticated. It should also be checked that sessions user id matches to id whose notes are being requested.

5. Cross-Site Request Forgery (CSRF)
App doesn't send csrf token in forms.

- Steps to identify:

Launch app, login to app, open new browser window and run similar url in browser: http://<theapp:port>/sendata?note=nocsrftoken
This url will make logged in user to send public comment "nocsrftoken" to site without being prompted.

- How to fix:

With flask it is possible to use CSRFProtect extension and initialize app with it. Then "{{ csrf_token() }}" just needs to be added to forms in hidden input and Flask will basically take care of less. If done manually, when creating user session the csrf token should be generated and added to users session, then send token to templates on requests, add it in forms input and check for the token on server side when form is submitted.